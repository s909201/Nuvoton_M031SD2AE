; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\clk.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -I.\RTE\_Template -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.9.0\CMSIS\Core\Include -IC:\Keil_v5\ARM\PACK\Nuvoton\NuMicro_DFP\1.3.18\Device\M031\Include -D__MICROLIB -D__UVISION_VERSION=535 -D_RTE_ -D_RTE_ --omf_browse=.\obj\clk.crf ..\..\..\Library\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;33       */
;;;34     void CLK_DisableCKO(void)
000000  4802              LDR      r0,|L1.12|
;;;35     {
;;;36         /* Disable CKO clock source */
;;;37         CLK->APBCLK0 &= (~CLK_APBCLK0_CLKOCKEN_Msk);
000002  6881              LDR      r1,[r0,#8]
000004  2240              MOVS     r2,#0x40
000006  4391              BICS     r1,r1,r2
000008  6081              STR      r1,[r0,#8]
;;;38     }
00000a  4770              BX       lr
;;;39     
                          ENDP

                  |L1.12|
                          DCD      0x40000200

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;589      */
;;;590    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;591    {
;;;592        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x8};    /* AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
000002  4909              LDR      r1,|L2.40|
000004  c90e              LDM      r1,{r1-r3}
;;;593    
;;;594        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L2.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4382              BICS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;595    }
000026  bd0e              POP      {r1-r3,pc}
;;;596    
                          ENDP

                  |L2.40|
                          DCD      ||.constdata||+0x2c
                  |L2.44|
                          DCD      0x40000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;744      */
;;;745    void CLK_DisablePLL(void)
000000  b510              PUSH     {r4,lr}
;;;746    {
;;;747        /* Switch HCLK to HIRC before disable PLL if current HCLK is PLL */
;;;748        if ((CLK->CLKSEL0 & CLK_CLKSEL0_HCLKSEL_Msk) == CLK_CLKSEL0_HCLKSEL_PLL)
000002  4c0c              LDR      r4,|L3.52|
000004  6920              LDR      r0,[r4,#0x10]
000006  0740              LSLS     r0,r0,#29
000008  0f40              LSRS     r0,r0,#29
00000a  2802              CMP      r0,#2
00000c  d10a              BNE      |L3.36|
;;;749        {
;;;750            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000e  6820              LDR      r0,[r4,#0]
000010  2104              MOVS     r1,#4
000012  4308              ORRS     r0,r0,r1
000014  6020              STR      r0,[r4,#0]
;;;751            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       CLK_WaitClockReady
;;;752            CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  2107              MOVS     r1,#7
000020  4308              ORRS     r0,r0,r1
000022  6120              STR      r0,[r4,#0x10]
                  |L3.36|
;;;753        }
;;;754    
;;;755        CLK->PLLCTL |= CLK_PLLCTL_PD_Msk;
000024  4803              LDR      r0,|L3.52|
000026  3040              ADDS     r0,r0,#0x40
000028  6801              LDR      r1,[r0,#0]
00002a  1382              ASRS     r2,r0,#14
00002c  4311              ORRS     r1,r1,r2
00002e  6001              STR      r1,[r0,#0]
;;;756    }
000030  bd10              POP      {r4,pc}
;;;757    
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      0x40000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;832      */
;;;833    void CLK_DisableSysTick(void)
000000  4901              LDR      r1,|L4.8|
;;;834    {
;;;835        /* Set System Tick counter disabled */
;;;836        SysTick->CTRL = 0;
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;837    }
000006  4770              BX       lr
;;;838    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;497      */
;;;498    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;499    {
;;;500        CLK->PWRCTL &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;501    }
000008  4770              BX       lr
;;;502    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;60       */
;;;61     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  0152              LSLS     r2,r2,#5
;;;62     {
;;;63         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;64         CLK->CLKOCTL = CLK_CLKOCTL_CLKOEN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_CLKOCTL_DIV1EN_Pos);
000002  430a              ORRS     r2,r2,r1
000004  2110              MOVS     r1,#0x10
000006  430a              ORRS     r2,r2,r1
000008  4906              LDR      r1,|L6.36|
00000a  620a              STR      r2,[r1,#0x20]
;;;65     
;;;66         /* Enable CKO clock source */
;;;67         CLK->APBCLK0 |= CLK_APBCLK0_CLKOCKEN_Msk;
00000c  4905              LDR      r1,|L6.36|
00000e  3940              SUBS     r1,r1,#0x40
000010  688a              LDR      r2,[r1,#8]
000012  2340              MOVS     r3,#0x40
000014  431a              ORRS     r2,r2,r3
000016  608a              STR      r2,[r1,#8]
;;;68     
;;;69         /* Select CKO clock source */
;;;70         CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_CLKOSEL_Msk)) | (u32ClkSrc);
000018  694a              LDR      r2,[r1,#0x14]
00001a  2370              MOVS     r3,#0x70
00001c  439a              BICS     r2,r2,r3
00001e  4302              ORRS     r2,r2,r0
000020  614a              STR      r2,[r1,#0x14]
;;;71     }
000022  4770              BX       lr
;;;72     
                          ENDP

                  |L6.36|
                          DCD      0x40000240

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;542      */
;;;543    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b50e              PUSH     {r1-r3,lr}
;;;544    {
;;;545        uint32_t u32ClkTbl[3] = {0x0, 0x4, 0x8};    /* AHBCLK/APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK0, 0x2:APBCLK1 */
000002  4909              LDR      r1,|L7.40|
000004  c90e              LDM      r1,{r1-r3}
;;;546    
;;;547        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + (u32ClkTbl[MODULE_APBCLK(u32ModuleIdx)]))  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000006  9100              STR      r1,[sp,#0]
000008  9201              STR      r2,[sp,#4]
00000a  0f81              LSRS     r1,r0,#30
00000c  008a              LSLS     r2,r1,#2
00000e  9302              STR      r3,[sp,#8]
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L7.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4302              ORRS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;548    }
000026  bd0e              POP      {r1-r3,pc}
;;;549    
                          ENDP

                  |L7.40|
                          DCD      ||.constdata||+0x20
                  |L7.44|
                          DCD      0x40000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;606      */
;;;607    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;608    {
000002  b087              SUB      sp,sp,#0x1c
000004  460d              MOV      r5,r1
000006  4607              MOV      r7,r0
;;;609        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC, u32Outdiv;
;;;610        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;611        uint32_t u32PLL_UpperLimit;
;;;612    
;;;613        /* Disable PLL first to avoid unstable when setting PLL */
;;;614        CLK_DisablePLL();
000008  f7fffffe          BL       CLK_DisablePLL
;;;615    
;;;616        /* PLL source clock is from HXT */
;;;617        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;618        {
;;;619            /* Enable HXT clock */
;;;620            CLK->PWRCTL |= CLK_PWRCTL_HXTEN_Msk;
00000c  4856              LDR      r0,|L8.360|
;;;621    
;;;622            /* Wait for HXT clock ready */
;;;623            CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;624    
;;;625            /* Select PLL source clock from HXT */
;;;626            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HXT;
;;;627            u32PllSrcClk = __HXT;
00000e  4e57              LDR      r6,|L8.364|
;;;628    
;;;629            /* u32NR start from 2 since NR = INDIV + 2 */
;;;630            u32NR = 2;
;;;631        }
;;;632    
;;;633        /* PLL source clock is from HIRC/4 */
;;;634        else
;;;635        {
;;;636            /* Enable HIRC clock */
;;;637            CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
000010  6801              LDR      r1,[r0,#0]
000012  2f00              CMP      r7,#0                 ;617
000014  d025              BEQ      |L8.98|
000016  2204              MOVS     r2,#4
000018  4311              ORRS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;638    
;;;639            /* Wait for HIRC clock ready */
;;;640            CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;641    
;;;642            /* Select PLL source clock from HIRC */
;;;643            u32CLK_SRC = CLK_PLLCTL_PLLSRC_HIRC_DIV4;
000022  2001              MOVS     r0,#1
000024  04c0              LSLS     r0,r0,#19
;;;644            u32PllSrcClk = __HIRC >> 2;
000026  9002              STR      r0,[sp,#8]
000028  4851              LDR      r0,|L8.368|
00002a  9003              STR      r0,[sp,#0xc]
                  |L8.44|
;;;645    
;;;646            /* u32NR start from 2 since NR = INDIV + 2 */
;;;647            u32NR = 2;
00002c  2402              MOVS     r4,#2
;;;648        }
;;;649    
;;;650        /* Select "NO" according to request frequency */
;;;651        /* Constraint: PLL output frequency must <= 96MHz */
;;;652        /*             PLL output frequency must > 50.14MHz to meet all constraints */
;;;653        if ((GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_G) || (GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_I))
00002e  0760              LSLS     r0,r4,#29
000030  6801              LDR      r1,[r0,#0]
;;;654            u32PLL_UpperLimit = FREQ_144MHZ;
;;;655        else
;;;656            u32PLL_UpperLimit = FREQ_96MHZ;
;;;657    
;;;658        if((u32PllFreq <= u32PLL_UpperLimit) && (u32PllFreq >= FREQ_51MHZ))
;;;659        {
;;;660            if (u32PllFreq <= FREQ_96MHZ)
;;;661            {
;;;662                u32NO = 4;
;;;663                u32Outdiv = 3;
;;;664                u32PllFreq = u32PllFreq << 2;   /* u32PllFreq = (FIN * NF / NR) now */
;;;665            }
;;;666            else
;;;667            {
;;;668                u32NO = 2;
;;;669                u32Outdiv = 2;
;;;670                u32PllFreq = u32PllFreq << 1;   /* u32PllFreq = (FIN * NF / NR) now */
;;;671            }
;;;672        }
;;;673        else
;;;674        {
;;;675            /* Wrong frequency request. Just return default setting. */
;;;676            goto lexit;
;;;677        }
;;;678    
;;;679        /* Find best solution */
;;;680        u32Min = (uint32_t) 0xFFFFFFFF; /* initial u32Min to max value of uint32_t */
;;;681        u32MinNR = 0;
;;;682        u32MinNF = 0;
;;;683        for(; u32NR <= 33; u32NR++) /* max NR = 33 since NR = INDIV + 2 and INDIV = 0 ~ 31 */
;;;684        {
;;;685            u32Tmp = u32PllSrcClk / u32NR;
;;;686            /* Constraint 2: 800KHz < (FIN / (2*NR)) < 8MHz */
;;;687            if((u32Tmp > 1600000) && (u32Tmp < 16000000))
;;;688            {
;;;689                for(u32NF = 2; u32NF <= 513; u32NF++) /* NF = 2~513 since NF = FBDIV + 2 and FBDIV = 0 ~ 511 */
;;;690                {
;;;691                    u32Tmp2 = u32Tmp * u32NF;
;;;692                    /* Constraint 3: 200MHz < (FIN * NF / NR) < 500MHz */
;;;693                    if((u32Tmp2 >= 200000000) && (u32Tmp2 < 500000000))
;;;694                    {
;;;695                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
;;;696                        if(u32Tmp3 < u32Min)
;;;697                        {
;;;698                            u32Min = u32Tmp3;
;;;699                            u32MinNR = u32NR;
;;;700                            u32MinNF = u32NF;
;;;701    
;;;702                            /* Break when get good results */
;;;703                            if(u32Min == 0)
;;;704                                break;
;;;705                        }
;;;706                    }
;;;707                }
;;;708            }
;;;709        }
;;;710    
;;;711        /* Enable and apply new PLL setting. */
;;;712        CLK->PLLCTL = u32CLK_SRC |
;;;713                      (u32Outdiv << CLK_PLLCTL_OUTDIV_Pos) |
;;;714                      ((u32MinNR - 2) << CLK_PLLCTL_INDIV_Pos) |
;;;715                      ((u32MinNF - 2) << CLK_PLLCTL_FBDIV_Pos);
;;;716    
;;;717        /* Wait for PLL clock stable */
;;;718        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;719    
;;;720        /* Return actual PLL output clock frequency */
;;;721        return (u32PllSrcClk / (u32NO * u32MinNR) * u32MinNF);
;;;722    
;;;723    lexit:
;;;724    
;;;725        /* Apply default PLL setting and return */
;;;726        if(u32PllClkSrc == CLK_PLLCTL_PLLSRC_HXT)
;;;727            CLK->PLLCTL = CLK_PLLCTL_96MHz_HXT;
;;;728        else
;;;729            CLK->PLLCTL = CLK_PLLCTL_96MHz_HIRC_DIV4;
;;;730    
;;;731        /* Wait for PLL clock stable */
;;;732        CLK_WaitClockReady(CLK_STATUS_PLLSTB_Msk);
;;;733    
;;;734        return CLK_GetPLLClockFreq();
;;;735    }
000032  0509              LSLS     r1,r1,#20
000034  0f0a              LSRS     r2,r1,#28
000036  494f              LDR      r1,|L8.372|
000038  2a06              CMP      r2,#6                 ;653
00003a  d01c              BEQ      |L8.118|
00003c  6800              LDR      r0,[r0,#0]            ;653
00003e  0500              LSLS     r0,r0,#20
000040  0f00              LSRS     r0,r0,#28
000042  2801              CMP      r0,#1                 ;653
000044  d017              BEQ      |L8.118|
000046  4608              MOV      r0,r1                 ;656
                  |L8.72|
000048  4285              CMP      r5,r0                 ;658
00004a  d85f              BHI      |L8.268|
00004c  484a              LDR      r0,|L8.376|
00004e  4285              CMP      r5,r0                 ;658
000050  d35c              BCC      |L8.268|
000052  428d              CMP      r5,r1                 ;660
000054  d811              BHI      |L8.122|
000056  2004              MOVS     r0,#4                 ;662
000058  9004              STR      r0,[sp,#0x10]         ;663
00005a  2003              MOVS     r0,#3                 ;663
00005c  00ad              LSLS     r5,r5,#2              ;664
00005e  9005              STR      r0,[sp,#0x14]         ;664
000060  e00f              B        |L8.130|
                  |L8.98|
000062  2201              MOVS     r2,#1                 ;620
000064  4311              ORRS     r1,r1,r2              ;620
000066  6001              STR      r1,[r0,#0]            ;620
000068  4610              MOV      r0,r2                 ;623
00006a  f7fffffe          BL       CLK_WaitClockReady
00006e  2000              MOVS     r0,#0                 ;626
000070  9603              STR      r6,[sp,#0xc]          ;630
000072  9002              STR      r0,[sp,#8]            ;630
000074  e7da              B        |L8.44|
                  |L8.118|
000076  4841              LDR      r0,|L8.380|
000078  e7e6              B        |L8.72|
                  |L8.122|
00007a  2002              MOVS     r0,#2                 ;668
00007c  9004              STR      r0,[sp,#0x10]         ;669
00007e  006d              LSLS     r5,r5,#1              ;670
000080  9005              STR      r0,[sp,#0x14]         ;670
                  |L8.130|
000082  2600              MOVS     r6,#0                 ;680
000084  43f6              MVNS     r6,r6                 ;680
000086  2000              MOVS     r0,#0                 ;681
000088  9000              STR      r0,[sp,#0]            ;682
00008a  9001              STR      r0,[sp,#4]            ;682
                  |L8.140|
00008c  4621              MOV      r1,r4                 ;685
00008e  9803              LDR      r0,[sp,#0xc]          ;685
000090  f7fffffe          BL       __aeabi_uidivmod
000094  493a              LDR      r1,|L8.384|
000096  1842              ADDS     r2,r0,r1              ;687
000098  493a              LDR      r1,|L8.388|
00009a  428a              CMP      r2,r1                 ;687
00009c  d216              BCS      |L8.204|
00009e  2202              MOVS     r2,#2                 ;689
                  |L8.160|
0000a0  4601              MOV      r1,r0                 ;689
0000a2  4b39              LDR      r3,|L8.392|
0000a4  4351              MULS     r1,r2,r1              ;691
0000a6  18cf              ADDS     r7,r1,r3              ;693
0000a8  4b38              LDR      r3,|L8.396|
0000aa  429f              CMP      r7,r3                 ;693
0000ac  d20a              BCS      |L8.196|
0000ae  42a9              CMP      r1,r5                 ;695
0000b0  d901              BLS      |L8.182|
0000b2  1b4b              SUBS     r3,r1,r5              ;695
0000b4  e000              B        |L8.184|
                  |L8.182|
0000b6  1a6b              SUBS     r3,r5,r1              ;695
                  |L8.184|
0000b8  42b3              CMP      r3,r6                 ;696
0000ba  d203              BCS      |L8.196|
0000bc  001e              MOVS     r6,r3                 ;698
0000be  9400              STR      r4,[sp,#0]            ;703
0000c0  9201              STR      r2,[sp,#4]            ;703
0000c2  d003              BEQ      |L8.204|
                  |L8.196|
0000c4  4932              LDR      r1,|L8.400|
0000c6  1c52              ADDS     r2,r2,#1              ;689
0000c8  428a              CMP      r2,r1                 ;689
0000ca  d9e9              BLS      |L8.160|
                  |L8.204|
0000cc  1c64              ADDS     r4,r4,#1              ;689
0000ce  2c21              CMP      r4,#0x21              ;683
0000d0  d9dc              BLS      |L8.140|
0000d2  9805              LDR      r0,[sp,#0x14]         ;712
0000d4  9902              LDR      r1,[sp,#8]            ;712
0000d6  0380              LSLS     r0,r0,#14             ;712
0000d8  4308              ORRS     r0,r0,r1              ;712
0000da  9900              LDR      r1,[sp,#0]            ;712
0000dc  024a              LSLS     r2,r1,#9              ;712
0000de  2101              MOVS     r1,#1                 ;712
0000e0  0289              LSLS     r1,r1,#10             ;712
0000e2  1a51              SUBS     r1,r2,r1              ;712
0000e4  4308              ORRS     r0,r0,r1              ;712
0000e6  9901              LDR      r1,[sp,#4]            ;712
0000e8  1e89              SUBS     r1,r1,#2              ;712
0000ea  4308              ORRS     r0,r0,r1              ;712
0000ec  491e              LDR      r1,|L8.360|
0000ee  3140              ADDS     r1,r1,#0x40           ;712
0000f0  6008              STR      r0,[r1,#0]            ;712
0000f2  2004              MOVS     r0,#4                 ;718
0000f4  f7fffffe          BL       CLK_WaitClockReady
0000f8  9904              LDR      r1,[sp,#0x10]         ;721
0000fa  9800              LDR      r0,[sp,#0]            ;721
0000fc  4341              MULS     r1,r0,r1              ;721
0000fe  9803              LDR      r0,[sp,#0xc]          ;721
000100  f7fffffe          BL       __aeabi_uidivmod
000104  9901              LDR      r1,[sp,#4]            ;721
000106  4348              MULS     r0,r1,r0              ;721
                  |L8.264|
000108  b007              ADD      sp,sp,#0x1c
00010a  bdf0              POP      {r4-r7,pc}
                  |L8.268|
00010c  2f00              CMP      r7,#0                 ;726
00010e  d015              BEQ      |L8.316|
000110  4920              LDR      r1,|L8.404|
                  |L8.274|
000112  4815              LDR      r0,|L8.360|
000114  3040              ADDS     r0,r0,#0x40           ;729
000116  6001              STR      r1,[r0,#0]            ;729
000118  2004              MOVS     r0,#4                 ;732
00011a  f7fffffe          BL       CLK_WaitClockReady
00011e  a01e              ADR      r0,|L8.408|
000120  6800              LDR      r0,[r0,#0]            ;732
000122  9000              STR      r0,[sp,#0]            ;732
000124  4910              LDR      r1,|L8.360|
000126  2000              MOVS     r0,#0                 ;732
000128  3140              ADDS     r1,r1,#0x40           ;732
00012a  6809              LDR      r1,[r1,#0]            ;732
00012c  2205              MOVS     r2,#5                 ;732
00012e  0412              LSLS     r2,r2,#16             ;732
000130  4211              TST      r1,r2                 ;732
000132  d1e9              BNE      |L8.264|
000134  0308              LSLS     r0,r1,#12             ;732
000136  d503              BPL      |L8.320|
000138  480d              LDR      r0,|L8.368|
00013a  e002              B        |L8.322|
                  |L8.316|
00013c  4917              LDR      r1,|L8.412|
00013e  e7e8              B        |L8.274|
                  |L8.320|
000140  4630              MOV      r0,r6                 ;727
                  |L8.322|
000142  038a              LSLS     r2,r1,#14             ;727
000144  d4e0              BMI      |L8.264|
000146  040a              LSLS     r2,r1,#16             ;727
000148  0f92              LSRS     r2,r2,#30             ;727
00014a  466b              MOV      r3,sp                 ;727
00014c  5c9b              LDRB     r3,[r3,r2]            ;727
00014e  05ca              LSLS     r2,r1,#23             ;727
000150  0489              LSLS     r1,r1,#18             ;727
000152  0dd2              LSRS     r2,r2,#23             ;727
000154  0ec9              LSRS     r1,r1,#27             ;727
000156  1c89              ADDS     r1,r1,#2              ;727
000158  0880              LSRS     r0,r0,#2              ;727
00015a  1c92              ADDS     r2,r2,#2              ;727
00015c  4359              MULS     r1,r3,r1              ;727
00015e  4350              MULS     r0,r2,r0              ;727
000160  f7fffffe          BL       __aeabi_uidivmod
000164  0080              LSLS     r0,r0,#2              ;727
000166  e7cf              B        |L8.264|
;;;736    
                          ENDP

                  |L8.360|
                          DCD      0x40000200
                  |L8.364|
                          DCD      0x01e84800
                  |L8.368|
                          DCD      0x00b71b00
                  |L8.372|
                          DCD      0x05b8d800
                  |L8.376|
                          DCD      0x030a32c0
                  |L8.380|
                          DCD      0x08954400
                  |L8.384|
                          DCD      0xffe795ff
                  |L8.388|
                          DCD      0x00dbb9ff
                  |L8.392|
                          DCD      0xf4143e00
                  |L8.396|
                          DCD      0x11e1a300
                  |L8.400|
                          DCD      0x00000201
                  |L8.404|
                          DCD      0x0008c25e
                  |L8.408|
000198  01020204          DCB      1,2,2,4
                  |L8.412|
                          DCD      0x0000cc5e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;805      */
;;;806    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count)
000000  b570              PUSH     {r4-r6,lr}
;;;807    {
;;;808        /* Set System Tick counter disabled */
;;;809        SysTick->CTRL = 0;
000002  4a0b              LDR      r2,|L9.48|
000004  2400              MOVS     r4,#0
000006  6114              STR      r4,[r2,#0x10]
;;;810    
;;;811        /* Set System Tick clock source */
;;;812        if(u32ClkSrc == CLK_CLKSEL0_STCLKSEL_HCLK)
000008  2804              CMP      r0,#4
00000a  d00c              BEQ      |L9.38|
;;;813            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;814        else
;;;815            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
00000c  4d09              LDR      r5,|L9.52|
00000e  692b              LDR      r3,[r5,#0x10]
000010  2638              MOVS     r6,#0x38
000012  43b3              BICS     r3,r3,r6
000014  4303              ORRS     r3,r3,r0
000016  612b              STR      r3,[r5,#0x10]
                  |L9.24|
;;;816    
;;;817        /* Set System Tick reload value */
;;;818        SysTick->LOAD = u32Count;
000018  6151              STR      r1,[r2,#0x14]
;;;819    
;;;820        /* Clear System Tick current value and counter flag */
;;;821        SysTick->VAL = 0;
00001a  6194              STR      r4,[r2,#0x18]
;;;822    
;;;823        /* Set System Tick interrupt enabled and counter enabled */
;;;824        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;
00001c  6910              LDR      r0,[r2,#0x10]
00001e  2103              MOVS     r1,#3
000020  4308              ORRS     r0,r0,r1
000022  6110              STR      r0,[r2,#0x10]
;;;825    }
000024  bd70              POP      {r4-r6,pc}
                  |L9.38|
000026  6910              LDR      r0,[r2,#0x10]         ;813
000028  2304              MOVS     r3,#4                 ;813
00002a  4318              ORRS     r0,r0,r3              ;813
00002c  6110              STR      r0,[r2,#0x10]         ;813
00002e  e7f3              B        |L9.24|
;;;826    
                          ENDP

                  |L9.48|
                          DCD      0xe000e000
                  |L9.52|
                          DCD      0x40000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;481      */
;;;482    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;483    {
;;;484        CLK->PWRCTL |= u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;485    }
000008  4770              BX       lr
;;;486    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x40000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;204      */
;;;205    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;206    {
;;;207        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;208        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;209    }
00000a  bd10              POP      {r4,pc}
;;;210    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;192      */
;;;193    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;196        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;197    }
00000a  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;134      */
;;;135    uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;136    {
;;;137        if(CLK->PWRCTL & CLK_PWRCTL_HXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;138            return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;139        else
;;;140            return 0;
;;;141    }
00000a  4770              BX       lr
;;;142    
                          ENDP

                  |L13.12|
                          DCD      0x40000200
                  |L13.16|
                          DCD      0x01e84800

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;148      */
;;;149    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;150    {
;;;151        if(CLK->PWRCTL & CLK_PWRCTL_LXTEN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L14.14|
;;;152            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;153        else
;;;154            return 0;
;;;155    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;154
000010  4770              BX       lr
;;;156    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40000200

                          AREA ||i.CLK_GetPCLK0Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK0Freq PROC
;;;162      */
;;;163    uint32_t CLK_GetPCLK0Freq(void)
000000  b510              PUSH     {r4,lr}
;;;164    {
;;;165        uint32_t PCLK0Div;
;;;166    
;;;167        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;168        PCLK0Div = (CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk) >> CLK_PCLKDIV_APB0DIV_Pos;
000006  4804              LDR      r0,|L15.24|
000008  6b40              LDR      r0,[r0,#0x34]
00000a  0741              LSLS     r1,r0,#29
;;;169        return (SystemCoreClock >> PCLK0Div);
00000c  4803              LDR      r0,|L15.28|
00000e  0f49              LSRS     r1,r1,#29             ;168
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  40c8              LSRS     r0,r0,r1
;;;170    }
000014  bd10              POP      {r4,pc}
;;;171    
                          ENDP

000016  0000              DCW      0x0000
                  |L15.24|
                          DCD      0x40000200
                  |L15.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetPCLK1Freq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLK1Freq PROC
;;;177      */
;;;178    uint32_t CLK_GetPCLK1Freq(void)
000000  b510              PUSH     {r4,lr}
;;;179    {
;;;180        uint32_t PCLK1Div;
;;;181    
;;;182        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;183        PCLK1Div = (CLK->PCLKDIV & CLK_PCLKDIV_APB1DIV_Msk) >> CLK_PCLKDIV_APB1DIV_Pos;
000006  4804              LDR      r0,|L16.24|
000008  6b40              LDR      r0,[r0,#0x34]
;;;184        return (SystemCoreClock >> PCLK1Div);
;;;185    }
00000a  0640              LSLS     r0,r0,#25
00000c  0f41              LSRS     r1,r0,#29
00000e  4803              LDR      r0,|L16.28|
000010  6800              LDR      r0,[r0,#0]            ;184  ; SystemCoreClock
000012  40c8              LSRS     r0,r0,r1              ;184
000014  bd10              POP      {r4,pc}
;;;186    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0x40000200
                  |L16.28|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;116      */
;;;117    void CLK_Idle(void)
000000  4805              LDR      r0,|L17.24|
;;;118    {
;;;119        /* Set the processor uses sleep as its low power mode */
;;;120        SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;121    
;;;122        /* Set chip in idle mode because of WFI command */
;;;123        CLK->PWRCTL &= ~CLK_PWRCTL_PDEN_Msk;
00000a  4804              LDR      r0,|L17.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4391              BICS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;124    
;;;125        /* Chip enter idle mode after CPU run WFI instruction */
;;;126        __WFI();
000014  bf30              WFI      
;;;127    }
000016  4770              BX       lr
;;;128    
                          ENDP

                  |L17.24|
                          DCD      0xe000ed00
                  |L17.28|
                          DCD      0x40000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;80       */
;;;81     void CLK_PowerDown(void)
000000  b508              PUSH     {r3,lr}
;;;82     {
;;;83         volatile uint32_t u32SysTickTICKINT = 0;    /* Backup Systick interrupt enable bit */
000002  2000              MOVS     r0,#0
;;;84     
;;;85         /* Check HIRC/MIRC auto trim function disable */
;;;86         if(SYS->HIRCTRIMCTL & SYS_HIRCTRIMCTL_FREQSEL_Msk)
000004  9000              STR      r0,[sp,#0]
000006  480f              LDR      r0,|L18.68|
000008  6b00              LDR      r0,[r0,#0x30]
00000a  0780              LSLS     r0,r0,#30
00000c  d118              BNE      |L18.64|
;;;87         {
;;;88             return;
;;;89         }
;;;90     
;;;91         /* Set the processor uses deep sleep as its low power mode */
;;;92         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000e  480e              LDR      r0,|L18.72|
000010  6901              LDR      r1,[r0,#0x10]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6101              STR      r1,[r0,#0x10]
;;;93     
;;;94         /* Set system Power-down enabled */
;;;95         CLK->PWRCTL |= CLK_PWRCTL_PDEN_Msk;
000018  480c              LDR      r0,|L18.76|
00001a  6801              LDR      r1,[r0,#0]
00001c  2280              MOVS     r2,#0x80
00001e  4311              ORRS     r1,r1,r2
000020  6001              STR      r1,[r0,#0]
;;;96     
;;;97         /* Backup systick interrupt setting */
;;;98         u32SysTickTICKINT = SysTick->CTRL & SysTick_CTRL_TICKINT_Msk;
000022  480b              LDR      r0,|L18.80|
000024  6902              LDR      r2,[r0,#0x10]
000026  2102              MOVS     r1,#2
000028  400a              ANDS     r2,r2,r1
;;;99     
;;;100        /* Disable systick interrupt */
;;;101        SysTick->CTRL &= ~SysTick_CTRL_TICKINT_Msk;
00002a  9200              STR      r2,[sp,#0]
00002c  6902              LDR      r2,[r0,#0x10]
00002e  438a              BICS     r2,r2,r1
000030  6102              STR      r2,[r0,#0x10]
;;;102    
;;;103        /* Chip enter Power-down mode after CPU run WFI instruction */
;;;104        __WFI();
000032  bf30              WFI      
;;;105    
;;;106        /* Restore systick interrupt setting */
;;;107        if(u32SysTickTICKINT) SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
000034  9a00              LDR      r2,[sp,#0]
000036  2a00              CMP      r2,#0
000038  d002              BEQ      |L18.64|
00003a  6902              LDR      r2,[r0,#0x10]
00003c  430a              ORRS     r2,r2,r1
00003e  6102              STR      r2,[r0,#0x10]
                  |L18.64|
;;;108    }
000040  bd08              POP      {r3,pc}
;;;109    
                          ENDP

000042  0000              DCW      0x0000
                  |L18.68|
                          DCD      0x400000c0
                  |L18.72|
                          DCD      0xe000ed00
                  |L18.76|
                          DCD      0x40000200
                  |L18.80|
                          DCD      0xe000e000

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;221      */
;;;222    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;223    {
;;;224        uint32_t u32HIRCSTB;
;;;225        uint32_t u32HCLK_UpperLimit;
;;;226    
;;;227        /* Read HIRC clock source stable flag */
;;;228        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4e24              LDR      r6,|L19.148|
000004  4604              MOV      r4,r0                 ;223
000006  6935              LDR      r5,[r6,#0x10]
000008  2010              MOVS     r0,#0x10
00000a  4005              ANDS     r5,r5,r0
;;;229    
;;;230        /* The range of u32Hclk is 25.5 MHz ~ 48 MHz or 72 MHz */
;;;231        if ((GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_G) || (GET_CHIP_SERIES_NUM == CHIP_SERIES_NUM_I))
00000c  0680              LSLS     r0,r0,#26
00000e  6801              LDR      r1,[r0,#0]
;;;232            u32HCLK_UpperLimit = FREQ_72MHZ;
;;;233        else
;;;234            u32HCLK_UpperLimit = FREQ_48MHZ;
;;;235    
;;;236        if(u32Hclk > u32HCLK_UpperLimit)
;;;237            u32Hclk = u32HCLK_UpperLimit;
;;;238        if(u32Hclk < (FREQ_51MHZ >> 1))
;;;239            u32Hclk = (FREQ_51MHZ >> 1);
;;;240    
;;;241        /* Switch HCLK clock source to HIRC clock for safe */
;;;242        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
;;;243        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
;;;244        CLK->CLKSEL0 |= CLK_CLKSEL0_HCLKSEL_Msk;
;;;245        CLK->CLKDIV0 &= (~CLK_CLKDIV0_HCLKDIV_Msk);
;;;246    
;;;247        /* Configure PLL setting if HXT clock is stable */
;;;248        if(CLK->STATUS & CLK_STATUS_HXTSTB_Msk)
;;;249            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HXT, (u32Hclk << 1));
;;;250    
;;;251        /* Configure PLL setting if HXT clock is not stable */
;;;252        else
;;;253        {
;;;254            u32Hclk = CLK_EnablePLL(CLK_PLLCTL_PLLSRC_HIRC_DIV4, (u32Hclk << 1));
;;;255    
;;;256            /* Read HIRC clock source stable flag */
;;;257            u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
;;;258        }
;;;259    
;;;260        /* Select HCLK clock source to PLL,
;;;261           Select HCLK clock source divider as 2
;;;262           and update system core clock
;;;263        */
;;;264        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_PLL, CLK_CLKDIV0_HCLK(2));
;;;265    
;;;266        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;267        if(u32HIRCSTB == 0)
;;;268            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
;;;269    
;;;270        /* Return actually HCLK frequency is PLL frequency divide 2 */
;;;271        return u32Hclk >> 1;
;;;272    }
000010  0509              LSLS     r1,r1,#20
000012  0f09              LSRS     r1,r1,#28
000014  2906              CMP      r1,#6                 ;231
000016  d026              BEQ      |L19.102|
000018  6800              LDR      r0,[r0,#0]            ;231
00001a  0500              LSLS     r0,r0,#20
00001c  0f00              LSRS     r0,r0,#28
00001e  2801              CMP      r0,#1                 ;231
000020  d021              BEQ      |L19.102|
000022  481d              LDR      r0,|L19.152|
                  |L19.36|
000024  4284              CMP      r4,r0                 ;236
000026  d900              BLS      |L19.42|
000028  4604              MOV      r4,r0                 ;237
                  |L19.42|
00002a  481c              LDR      r0,|L19.156|
00002c  4284              CMP      r4,r0                 ;238
00002e  d200              BCS      |L19.50|
000030  4604              MOV      r4,r0                 ;239
                  |L19.50|
000032  4f18              LDR      r7,|L19.148|
000034  3f40              SUBS     r7,r7,#0x40           ;242
000036  6838              LDR      r0,[r7,#0]            ;242
000038  2104              MOVS     r1,#4                 ;242
00003a  4308              ORRS     r0,r0,r1              ;242
00003c  6038              STR      r0,[r7,#0]            ;242
00003e  2010              MOVS     r0,#0x10              ;243
000040  f7fffffe          BL       CLK_WaitClockReady
000044  6938              LDR      r0,[r7,#0x10]         ;244
000046  2107              MOVS     r1,#7                 ;244
000048  4308              ORRS     r0,r0,r1              ;244
00004a  6138              STR      r0,[r7,#0x10]         ;244
00004c  6a38              LDR      r0,[r7,#0x20]         ;245
00004e  0900              LSRS     r0,r0,#4              ;245
000050  0100              LSLS     r0,r0,#4              ;245
000052  6238              STR      r0,[r7,#0x20]         ;245
000054  6930              LDR      r0,[r6,#0x10]         ;248
000056  07c0              LSLS     r0,r0,#31             ;248
000058  d007              BEQ      |L19.106|
00005a  0061              LSLS     r1,r4,#1              ;249
00005c  2000              MOVS     r0,#0                 ;249
00005e  f7fffffe          BL       CLK_EnablePLL
000062  4604              MOV      r4,r0                 ;249
000064  e00a              B        |L19.124|
                  |L19.102|
000066  480e              LDR      r0,|L19.160|
000068  e7dc              B        |L19.36|
                  |L19.106|
00006a  2001              MOVS     r0,#1                 ;254
00006c  0061              LSLS     r1,r4,#1              ;254
00006e  04c0              LSLS     r0,r0,#19             ;254
000070  f7fffffe          BL       CLK_EnablePLL
000074  6935              LDR      r5,[r6,#0x10]         ;257
000076  4604              MOV      r4,r0                 ;254
000078  2010              MOVS     r0,#0x10              ;257
00007a  4005              ANDS     r5,r5,r0              ;257
                  |L19.124|
00007c  2101              MOVS     r1,#1                 ;264
00007e  2002              MOVS     r0,#2                 ;264
000080  f7fffffe          BL       CLK_SetHCLK
000084  2d00              CMP      r5,#0                 ;267
000086  d103              BNE      |L19.144|
000088  6839              LDR      r1,[r7,#0]            ;268
00008a  2004              MOVS     r0,#4                 ;268
00008c  4381              BICS     r1,r1,r0              ;268
00008e  6039              STR      r1,[r7,#0]            ;268
                  |L19.144|
000090  0860              LSRS     r0,r4,#1              ;271
000092  bdf8              POP      {r3-r7,pc}
;;;273    
                          ENDP

                  |L19.148|
                          DCD      0x40000240
                  |L19.152|
                          DCD      0x02dc6c00
                  |L19.156|
                          DCD      0x01851960
                  |L19.160|
                          DCD      0x044aa200

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;287      */
;;;288    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;289    {
;;;290        uint32_t u32HIRCSTB;
;;;291    
;;;292        /* Read HIRC clock source stable flag */
;;;293        u32HIRCSTB = CLK->STATUS & CLK_STATUS_HIRCSTB_Msk;
000002  4812              LDR      r0,|L20.76|
000004  b081              SUB      sp,sp,#4              ;289
000006  6905              LDR      r5,[r0,#0x10]
000008  460f              MOV      r7,r1                 ;289
00000a  2010              MOVS     r0,#0x10
;;;294    
;;;295        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;296        CLK->PWRCTL |= CLK_PWRCTL_HIRCEN_Msk;
00000c  4c0f              LDR      r4,|L20.76|
00000e  4005              ANDS     r5,r5,r0              ;293
000010  3c40              SUBS     r4,r4,#0x40
000012  6820              LDR      r0,[r4,#0]
000014  2604              MOVS     r6,#4
000016  4330              ORRS     r0,r0,r6
000018  6020              STR      r0,[r4,#0]
;;;297        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       CLK_WaitClockReady
;;;298        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | CLK_CLKSEL0_HCLKSEL_HIRC;
000020  6920              LDR      r0,[r4,#0x10]
000022  2107              MOVS     r1,#7
000024  4308              ORRS     r0,r0,r1
000026  6120              STR      r0,[r4,#0x10]
;;;299    
;;;300        /* Apply new Divider */
;;;301        CLK->CLKDIV0 = (CLK->CLKDIV0 & (~CLK_CLKDIV0_HCLKDIV_Msk)) | u32ClkDiv;
000028  6a20              LDR      r0,[r4,#0x20]
00002a  0900              LSRS     r0,r0,#4
00002c  0100              LSLS     r0,r0,#4
00002e  4338              ORRS     r0,r0,r7
000030  6220              STR      r0,[r4,#0x20]
;;;302    
;;;303        /* Switch HCLK to new HCLK source */
;;;304        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLKSEL_Msk)) | u32ClkSrc;
000032  6920              LDR      r0,[r4,#0x10]
000034  4388              BICS     r0,r0,r1
000036  9901              LDR      r1,[sp,#4]
000038  4308              ORRS     r0,r0,r1
00003a  6120              STR      r0,[r4,#0x10]
;;;305    
;;;306        /* Update System Core Clock */
;;;307        SystemCoreClockUpdate();
00003c  f7fffffe          BL       SystemCoreClockUpdate
;;;308    
;;;309        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;310        if(u32HIRCSTB == 0)
000040  2d00              CMP      r5,#0
000042  d102              BNE      |L20.74|
;;;311            CLK->PWRCTL &= ~CLK_PWRCTL_HIRCEN_Msk;
000044  6820              LDR      r0,[r4,#0]
000046  43b0              BICS     r0,r0,r6
000048  6020              STR      r0,[r4,#0]
                  |L20.74|
;;;312    }
00004a  bdfe              POP      {r1-r7,pc}
;;;313    
                          ENDP

                  |L20.76|
                          DCD      0x40000240

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;430      */
;;;431    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;432    {
;;;433        uint32_t u32sel = 0, u32div = 0;
;;;434        uint32_t u32SelTbl[4] = {0x0, 0x4, 0x8, 0xC};   /* CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
000002  4b19              LDR      r3,|L21.104|
000004  b088              SUB      sp,sp,#0x20           ;432
000006  cbf0              LDM      r3!,{r4-r7}
000008  9400              STR      r4,[sp,#0]
00000a  ac01              ADD      r4,sp,#4
00000c  c4e0              STM      r4!,{r5-r7}
00000e  cb78              LDM      r3,{r3-r6}
000010  af04              ADD      r7,sp,#0x10
000012  c778              STM      r7!,{r3-r6}
;;;435        uint32_t u32DivTbl[4] = {0x0, 0x0, 0x0, 0x10};  /* CLKDIV offset on MODULE index, 0x0:CLKDIV0, 0x1:CLKDIV1, 0x2:CLKDIV3, 0x3:CLKDIV4 */
;;;436    
;;;437        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000014  0a84              LSRS     r4,r0,#10
000016  0623              LSLS     r3,r4,#24
000018  0e1b              LSRS     r3,r3,#24
00001a  d00e              BEQ      |L21.58|
;;;438        {
;;;439            /* Get clock divider control register address */
;;;440            u32div = (uint32_t)&CLK->CLKDIV0 + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
00001c  0303              LSLS     r3,r0,#12
00001e  0f9b              LSRS     r3,r3,#30
000020  009b              LSLS     r3,r3,#2
000022  ad04              ADD      r5,sp,#0x10
000024  58eb              LDR      r3,[r5,r3]
000026  4d11              LDR      r5,|L21.108|
000028  195b              ADDS     r3,r3,r5
;;;441            /* Apply new divider */
;;;442            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
00002a  b2e5              UXTB     r5,r4
00002c  0584              LSLS     r4,r0,#22
00002e  0ee4              LSRS     r4,r4,#27
000030  40a5              LSLS     r5,r5,r4
000032  681c              LDR      r4,[r3,#0]
000034  43ac              BICS     r4,r4,r5
000036  4314              ORRS     r4,r4,r2
000038  601c              STR      r4,[r3,#0]
                  |L21.58|
;;;443        }
;;;444    
;;;445        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
00003a  0e42              LSRS     r2,r0,#25
00003c  0752              LSLS     r2,r2,#29
00003e  d010              BEQ      |L21.98|
;;;446        {
;;;447            /* Get clock select control register address */
;;;448            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
000040  0082              LSLS     r2,r0,#2
000042  0f92              LSRS     r2,r2,#30
000044  0092              LSLS     r2,r2,#2
000046  466b              MOV      r3,sp
000048  589a              LDR      r2,[r3,r2]
00004a  4b08              LDR      r3,|L21.108|
00004c  3b10              SUBS     r3,r3,#0x10
00004e  18d2              ADDS     r2,r2,r3
;;;449            /* Set new clock selection setting */
;;;450            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
000050  0103              LSLS     r3,r0,#4
000052  0f5b              LSRS     r3,r3,#29
000054  01c0              LSLS     r0,r0,#7
000056  0ec0              LSRS     r0,r0,#27
000058  4083              LSLS     r3,r3,r0
00005a  6810              LDR      r0,[r2,#0]
00005c  4398              BICS     r0,r0,r3
00005e  4308              ORRS     r0,r0,r1
000060  6010              STR      r0,[r2,#0]
                  |L21.98|
;;;451        }
;;;452    }
000062  b008              ADD      sp,sp,#0x20
000064  bdf0              POP      {r4-r7,pc}
;;;453    
                          ENDP

000066  0000              DCW      0x0000
                  |L21.104|
                          DCD      ||.constdata||
                  |L21.108|
                          DCD      0x40000220

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;465      */
;;;466    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L22.16|
;;;467    {
;;;468        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLKSEL_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;469    }
00000c  4770              BX       lr
;;;470    
                          ENDP

00000e  0000              DCW      0x0000
                  |L22.16|
                          DCD      0x40000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;770      */
;;;771    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b570              PUSH     {r4-r6,lr}
;;;772    {
000002  4605              MOV      r5,r0
;;;773        uint32_t u32TimeOutCnt = SystemCoreClock / 2;
000004  480b              LDR      r0,|L23.52|
;;;774        uint32_t u32Ret = 1U;
000006  2201              MOVS     r2,#1
000008  6800              LDR      r0,[r0,#0]            ;773  ; SystemCoreClock
;;;775    
;;;776        g_CLK_i32ErrCode = 0;
00000a  4b0b              LDR      r3,|L23.56|
00000c  0841              LSRS     r1,r0,#1              ;773
00000e  2000              MOVS     r0,#0
;;;777        while((CLK->STATUS & u32ClkMask) != u32ClkMask)
000010  4c0a              LDR      r4,|L23.60|
000012  6018              STR      r0,[r3,#0]            ;772  ; g_CLK_i32ErrCode
000014  e001              B        |L23.26|
                  |L23.22|
000016  1e49              SUBS     r1,r1,#1              ;772
;;;778        {
;;;779            if(--u32TimeOutCnt == 0)
000018  d006              BEQ      |L23.40|
                  |L23.26|
00001a  6926              LDR      r6,[r4,#0x10]         ;777
00001c  4628              MOV      r0,r5                 ;777
00001e  43b0              BICS     r0,r0,r6              ;777
000020  d1f9              BNE      |L23.22|
;;;780            {
;;;781                u32Ret = 0U;
;;;782                break;
;;;783            }
;;;784        }
;;;785    
;;;786        if(u32TimeOutCnt == 0)
000022  2900              CMP      r1,#0
000024  d001              BEQ      |L23.42|
000026  e003              B        |L23.48|
                  |L23.40|
000028  2200              MOVS     r2,#0                 ;781
                  |L23.42|
;;;787            g_CLK_i32ErrCode = CLK_TIMEOUT_ERR;
00002a  2000              MOVS     r0,#0
00002c  43c0              MVNS     r0,r0
00002e  6018              STR      r0,[r3,#0]  ; g_CLK_i32ErrCode
                  |L23.48|
;;;788    
;;;789        return u32Ret;
000030  4610              MOV      r0,r2
;;;790    }
000032  bd70              POP      {r4-r6,pc}
;;;791    
                          ENDP

                  |L23.52|
                          DCD      SystemCoreClock
                  |L23.56|
                          DCD      ||.data||
                  |L23.60|
                          DCD      0x40000240

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x0000000c
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000010
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000008

                          AREA ||.data||, DATA, ALIGN=2

                  g_CLK_i32ErrCode
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_clk_c_9a445bc2____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9a445bc2____REVSH|
#line 402
|__asm___5_clk_c_9a445bc2____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
